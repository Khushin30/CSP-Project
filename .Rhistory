frequency_tables
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) == 0)  # Assuming majority class is where all columns are 0
minority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) > 0)   # Assuming minority class is where at least one column is 1
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("change_cat", "moon", "slash", "plus", "star", "two", "lunar", "solar")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) == 0)  # Assuming majority class is where all columns are 0
minority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) > 0)   # Assuming minority class is where at least one column is 1
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) == 0)  # Assuming majority class is where all columns are 0
minority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) > 0)   # Assuming minority class is where at least one column is 1
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,c("moon", "slash", "plus", "star", "two", "flare")], table)
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flares")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) == 0)  # Assuming majority class is where all columns are 0
minority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) > 0)   # Assuming minority class is where at least one column is 1
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,predictor_columns], table)
frequency_tables
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_solar_event = ifelse(rowSums(balanced_data[predictor_columns]) > 0, 1, 0)
# now lets see if this can show us any correlations
pairs.panels(balanced_data[c("has_solar_event", "net_change")], main = "Pairs Plot of Solar Event vs. net_change")
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("change_cat", "moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_solar_event = ifelse(rowSums(balanced_data[predictor_columns]) > 0, 1, 0)
balanced_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("change_cat", "moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("change_cat", "moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
processed_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
# now lets see if this can show us any correlations
pairs.panels(balanced_data[c("has_solar_event", "net_change")], main = "Pairs Plot of Solar Event vs. net_change")
processed_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
# now lets see if this can show us any correlations
pairs.panels(processed_data[c("has_solar_event", "net_change")], main = "Pairs Plot of Solar Event vs. net_change")
processed_data
linear_model <- lm(processed_data~. - has_solar_event)
linear_model <- lm(processed_data ~ . - has_solar_event)
linear_model <- lm(net_change ~ . - has_solar_event, data = processed_data)
summary(linear_model)
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) == 0)  # Assuming majority class is where all columns are 0
minority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) > 0)   # Assuming minority class is where at least one column is 1
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,predictor_columns], table)
frequency_tables
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
# now lets see if this can show us any correlations
pairs.panels(processed_data[c("has_solar_event", "net_change")], main = "Pairs Plot of Solar Event vs. net_change")
linear_model <- lm(net_change ~ . - has_solar_event, data = processed_data)
summary(linear_model)
# lets see the first 10 of the data we're working with
main_data <- read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
# lets record the change in the stocks value as net_change and create a new df with it
net_change <- main_data$change
processed_data <- data.frame(net_change)
# lets also carry over the values from the Date, moon, slash, plus, star, two, and flare columns
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data <- cbind(processed_data,main_data[, predictor_columns])
processed_data <- na.omit(processed_data)
processed_data
# Let's see the frequencies for each column
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) == 0)  # Assuming majority class is where all columns are 0
minority_class <- subset(processed_data, rowSums(processed_data[predictor_columns]) > 0)   # Assuming minority class is where at least one column is 1
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,predictor_columns], table)
frequency_tables
# lets see which variables are relevant to predicting the net change
library(psych)
columns_for_pairs <- c(predictor_columns, "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_solar_event = ifelse(rowSums(processed_data[predictor_columns]) > 0, 1, 0)
# now lets see if this can show us any correlations
pairs.panels(processed_data[c("has_solar_event", "net_change")], main = "Pairs Plot of Solar Event vs. net_change")
linear_model <- lm(net_change ~ . - has_solar_event, data = processed_data)
summary(linear_model)
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_aal.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_ba.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_lmt.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_sp.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_ba.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
# lets see the first 10 of the data we're working with
main_data = read.csv("./Data Files/data_sp.csv")
head(main_data, 10)
predictor_columns <- c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
processed_data = main_data[, predictor_columns]
processed_data$net_change = main_data$change
processed_data$cat_change = main_data$change_cat
head(processed_data, 10)
frequency_tables <- lapply(processed_data[,predictor_columns], table)
frequency_tables
imbalanced_predictors = c("moon", "slash", "plus", "star", "two", "lunar", "solar", "flare")
# GPT generated code
majority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) == 0)
minority_class <- subset(processed_data, rowSums(processed_data[imbalanced_predictors]) > 0)
undersampled_majority <- majority_class[sample(nrow(majority_class), nrow(minority_class), replace = FALSE), ]
# Combine undersampled majority class and minority class
balanced_data <- rbind(undersampled_majority, minority_class)
head(balanced_data, 10)
# lets see how the data is distributed now in our balanced dataset and shuffle it
balanced_data <- balanced_data[sample(nrow(balanced_data)), ]
frequency_tables <- lapply(balanced_data[,imbalanced_predictors], table)
frequency_tables
library(psych)
columns_for_pairs <- c(imbalanced_predictors, "net_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
processed_data$has_event = ifelse(rowSums(processed_data[, imbalanced_predictors]) > 0, 1, 0)
head(processed_data, 10)
columns_for_pairs <- c("has_event", "net_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
balanced_data$has_event = ifelse(rowSums(balanced_data[, imbalanced_predictors]) > 0, 1, 0)
head(balanced_data, 10)
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Columns vs. net_change")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(processed_data[columns_for_pairs], main = "Pairs Plot of Columns vs. Cat_change")
predictor_columns <- c("moon", "slash",  "plus", "star", "two", "lunar", "solar", "flare")
columns_for_pairs <- c(imbalanced_predictors, "has_event", "cat_change")
# Create pairs plot
pairs.panels(balanced_data[columns_for_pairs], main = "Pairs Plot of Balanced Columns  vs. Cat_change")
